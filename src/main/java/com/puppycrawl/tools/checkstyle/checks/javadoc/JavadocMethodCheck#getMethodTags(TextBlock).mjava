    /**
     * Returns the tags in a javadoc comment. Only finds throws, exception,
     * param, return and see tags.
     *
     * @param comment the Javadoc comment
     * @return the tags found
     */
    private static List<JavadocTag> getMethodTags(TextBlock comment) {
        final String[] lines = comment.getText();
        final List<JavadocTag> tags = Lists.newArrayList();
        int currentLine = comment.getStartLineNo() - 1;

        for (int i = 0; i < lines.length; i++) {
            currentLine++;
            final Matcher javadocArgMatcher =
                MATCH_JAVADOC_ARG.matcher(lines[i]);
            final Matcher javadocNoargMatcher =
                MATCH_JAVADOC_NOARG.matcher(lines[i]);
            final Matcher noargCurlyMatcher =
                MATCH_JAVADOC_NOARG_CURLY.matcher(lines[i]);
            final Matcher argMultilineStart =
                MATCH_JAVADOC_ARG_MULTILINE_START.matcher(lines[i]);
            final Matcher noargMultilineStart =
                MATCH_JAVADOC_NOARG_MULTILINE_START.matcher(lines[i]);

            if (javadocArgMatcher.find()) {
                int col = javadocArgMatcher.start(1) - 1;
                if (i == 0) {
                    col += comment.getStartColNo();
                }
                tags.add(new JavadocTag(currentLine, col, javadocArgMatcher
                        .group(1), javadocArgMatcher.group(2)));
            }
            else if (javadocNoargMatcher.find()) {
                int col = javadocNoargMatcher.start(1) - 1;
                if (i == 0) {
                    col += comment.getStartColNo();
                }
                tags.add(new JavadocTag(currentLine, col, javadocNoargMatcher
                        .group(1)));
            }
            else if (noargCurlyMatcher.find()) {
                int col = noargCurlyMatcher.start(1) - 1;
                if (i == 0) {
                    col += comment.getStartColNo();
                }
                tags.add(new JavadocTag(currentLine, col, noargCurlyMatcher
                        .group(1)));
            }
            else if (argMultilineStart.find()) {
                final String p1 = argMultilineStart.group(1);
                final String p2 = argMultilineStart.group(2);
                int col = argMultilineStart.start(1) - 1;
                if (i == 0) {
                    col += comment.getStartColNo();
                }

                // Look for the rest of the comment if all we saw was
                // the tag and the name. Stop when we see '*/' (end of
                // Javadoc), '@' (start of next tag), or anything that's
                // not whitespace or '*' characters.
                int remIndex = i + 1;
                while (remIndex < lines.length) {
                    final Matcher multilineCont = MATCH_JAVADOC_MULTILINE_CONT
                            .matcher(lines[remIndex]);
                    if (multilineCont.find()) {
                        remIndex = lines.length;
                        final String lFin = multilineCont.group(1);
                        if (!lFin.equals(NEXT_TAG)
                            && !lFin.equals(END_JAVADOC)) {
                            tags.add(new JavadocTag(currentLine, col, p1, p2));
                        }
                    }
                    remIndex++;
                }
            }
            else if (noargMultilineStart.find()) {
                final String p1 = noargMultilineStart.group(1);
                int col = noargMultilineStart.start(1) - 1;
                if (i == 0) {
                    col += comment.getStartColNo();
                }

                // Look for the rest of the comment if all we saw was
                // the tag and the name. Stop when we see '*/' (end of
                // Javadoc), '@' (start of next tag), or anything that's
                // not whitespace or '*' characters.
                int remIndex = i + 1;
                while (remIndex < lines.length) {
                    final Matcher multilineCont = MATCH_JAVADOC_MULTILINE_CONT
                            .matcher(lines[remIndex]);
                    if (multilineCont.find()) {
                        remIndex = lines.length;
                        final String lFin = multilineCont.group(1);
                        if (!lFin.equals(NEXT_TAG)
                            && !lFin.equals(END_JAVADOC)) {
                            tags.add(new JavadocTag(currentLine, col, p1));
                        }
                    }
                    remIndex++;
                }
            }
        }
        return tags;
    }

