    /**
     * Update current scope data uninitialized variable according to the previous scope data.
     * @param prevScopeUnitializedVariableData variable for previous stack of uninitialized
     *     variables
     */
    // -@cs[CyclomaticComplexity] Breaking apart will damage encapsulation.
    private void updateUninitializedVariables(Deque<DetailAST> prevScopeUnitializedVariableData) {
        // Check for only previous scope
        for (DetailAST variable : prevScopeUnitializedVariableData) {
            for (ScopeData scopeData : scopeStack) {
                final FinalVariableCandidate candidate = scopeData.scope.get(variable.getText());
                DetailAST storedVariable = null;
                if (candidate != null) {
                    storedVariable = candidate.variableIdent;
                }
                if (storedVariable != null && isSameVariables(storedVariable, variable)
                        && !scopeData.uninitializedVariables.contains(storedVariable)) {
                    scopeData.uninitializedVariables.push(variable);
                }
            }
        }
        // Check for rest of the scope
        for (Deque<DetailAST> unitializedVariableData : prevScopeUninitializedVariables) {
            for (DetailAST variable : unitializedVariableData) {
                for (ScopeData scopeData : scopeStack) {
                    final FinalVariableCandidate candidate =
                        scopeData.scope.get(variable.getText());
                    DetailAST storedVariable = null;
                    if (candidate != null) {
                        storedVariable = candidate.variableIdent;
                    }
                    if (storedVariable != null
                            && isSameVariables(storedVariable, variable)
                            && !scopeData.uninitializedVariables.contains(storedVariable)) {
                        scopeData.uninitializedVariables.push(variable);
                    }
                }
            }
        }
    }

