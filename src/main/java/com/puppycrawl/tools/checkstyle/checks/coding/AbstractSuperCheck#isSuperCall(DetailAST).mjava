    /**
     *  Determines whether a 'super' literal is a call to the super method
     * for this check.
     * @param ast the AST node of a 'super' literal.
     * @return true if ast is a call to the super method
     * for this check.
     */
    private boolean isSuperCall(DetailAST ast)
    {
        if (ast.getType() != TokenTypes.LITERAL_SUPER) {
            return false;
        }
        // dot operator?
        DetailAST parent = ast.getParent();
        if ((parent == null) || (parent.getType() != TokenTypes.DOT)) {
            return false;
        }

        // same name of method
        AST sibling = ast.getNextSibling();
        // ignore type parameters
        if ((sibling != null)
            && (sibling.getType() == TokenTypes.TYPE_ARGUMENTS))
        {
            sibling = sibling.getNextSibling();
        }
        if ((sibling == null) || (sibling.getType() != TokenTypes.IDENT)) {
            return false;
        }
        final String name = sibling.getText();
        if (!getMethodName().equals(name)) {
            return false;
        }

        // 0 parameters?
        final DetailAST args = parent.getNextSibling();
        if ((args == null) || (args.getType() != TokenTypes.ELIST)) {
            return false;
        }
        if (args.getChildCount() != 0) {
            return false;
        }

        // in an overriding method for this check?
        while (parent != null) {
            if (parent.getType() == TokenTypes.METHOD_DEF) {
                return isOverridingMethod(parent);
            }
            else if ((parent.getType() == TokenTypes.CTOR_DEF)
                || (parent.getType() == TokenTypes.INSTANCE_INIT))
            {
                return false;
            }
            parent = parent.getParent();
        }
        return false;
    }

