    /**
     * Get the handler for an AST.
     *
     * @param indentCheck   the indentation check
     * @param ast           ast to handle
     * @param parent        the handler parent of this AST
     *
     * @return the ExpressionHandler for ast
     */
    public ExpressionHandler getHandler(IndentationCheck indentCheck,
        DetailAST ast, ExpressionHandler parent)
    {
        final ExpressionHandler handler =
            createdHandlers.get(ast);
        if (handler != null) {
            return handler;
        }

        if (ast.getType() == TokenTypes.METHOD_CALL) {
            return createMethodCallHandler(indentCheck, ast, parent);
        }

        ExpressionHandler expHandler = null;
        try {
            final Constructor<?> handlerCtor =
                typeHandlers.get(ast.getType());
            if (handlerCtor != null) {
                expHandler = (ExpressionHandler) handlerCtor.newInstance(
                        indentCheck, ast, parent);
            }
        }
        ///CLOVER:OFF
        catch (final InstantiationException e) {
            LOG.debug("couldn't instantiate constructor for " + ast, e);
            throw new RuntimeException("couldn't instantiate constructor for "
                                       + ast);
        }
        catch (final IllegalAccessException e) {
            LOG.debug("couldn't access constructor for " + ast, e);
            throw new RuntimeException("couldn't access constructor for "
                                       + ast);
        }
        catch (final InvocationTargetException e) {
            LOG.debug("couldn't instantiate constructor for " + ast, e);
            throw new RuntimeException("couldn't instantiate constructor for "
                                       + ast);
        }
        if (expHandler == null) {
            throw new RuntimeException("no handler for type " + ast.getType());
        }
        ///CLOVER:ON
        return expHandler;
    }

