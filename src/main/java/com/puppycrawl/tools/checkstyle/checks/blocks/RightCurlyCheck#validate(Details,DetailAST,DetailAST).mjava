    /**
     * Does general validation.
     * @param details details.
     * @param rcurly right curly token.
     * @param lcurly left curly token.
     */
    private void validate(Details details, DetailAST rcurly, DetailAST lcurly) {
        final DetailAST nextToken = details.nextToken;
        final boolean shouldCheckLastRcurly = details.shouldCheckLastRcurly;

        if (getAbstractOption() == RightCurlyOption.SAME
                && !hasLineBreakBefore(rcurly)) {
            log(rcurly, MSG_KEY_LINE_BREAK_BEFORE, "}", rcurly.getColumnNo() + 1);
        }
        else if (shouldCheckLastRcurly) {
            if (rcurly.getLineNo() == nextToken.getLineNo()) {
                log(rcurly, MSG_KEY_LINE_ALONE, "}", rcurly.getColumnNo() + 1);
            }
        }
        else if (getAbstractOption() == RightCurlyOption.SAME
                && rcurly.getLineNo() != nextToken.getLineNo()) {
            log(rcurly, MSG_KEY_LINE_SAME, "}", rcurly.getColumnNo() + 1);
        }
        else if (getAbstractOption() == RightCurlyOption.ALONE
                && !isAloneOnLine(details)
                && !isEmptyBody(lcurly)) {
            log(rcurly, MSG_KEY_LINE_ALONE, "}", rcurly.getColumnNo() + 1);
        }
        else if (getAbstractOption() == RightCurlyOption.ALONE_OR_SINGLELINE
                && !isAloneOnLine(details)
                && !isSingleLineBlock(details)
                && !isAnonInnerClassInit(lcurly)
                && !isEmptyBody(lcurly)) {
            log(rcurly, MSG_KEY_LINE_ALONE, "}", rcurly.getColumnNo() + 1);
        }
        else if (shouldStartLine) {
            final boolean startsLine =
                Utils.whitespaceBefore(rcurly.getColumnNo(),
                    getLines()[rcurly.getLineNo() - 1]);

            if (!startsLine && lcurly.getLineNo() != rcurly.getLineNo()) {
                log(rcurly, MSG_KEY_LINE_NEW, "}", rcurly.getColumnNo() + 1);
            }
        }
    }

