    /**
     * Checks that if overload methods are grouped together they should not be
     * separated from each other.
     * @param aObjectBlock
     *        is a class, interface or enum object block.
     */
    private void checkOverloadMethodsGrouping(DetailAST aObjectBlock)
    {
        final int allowedDistance = 1;
        DetailAST currentToken = aObjectBlock.getFirstChild();
        final Map<String, Integer> methodIndexMap = new HashMap<String, Integer>();
        final Map<String, Integer> methodLineNumberMap = new HashMap<String, Integer>();
        int currentIndex = 0;
        while (currentToken != null) {
            if (currentToken.getType() == TokenTypes.METHOD_DEF) {
                currentIndex++;
                final String methodName =
                        currentToken.findFirstToken(TokenTypes.IDENT).getText();
                if (methodIndexMap.containsKey(methodName)) {
                    final int priviousIndex = methodIndexMap.get(methodName);
                    if (currentIndex - priviousIndex > allowedDistance) {
                        final int previousLineWithOverloadMethod =
                                methodLineNumberMap.get(methodName);
                        log(currentToken.getLineNo(), "overload.methods.declaration",
                                previousLineWithOverloadMethod);
                    }
                }
                methodIndexMap.put(methodName, currentIndex);
                methodLineNumberMap.put(methodName, currentToken.getLineNo());
            }
            currentToken = currentToken.getNextSibling();
        }
    }

