    /**
     * Called to process tokens other than {@link TokenTypes.VARIABLE_DEF}
     * and {@link TokenTypes.PARAMETER_DEF}
     *
     * @param ast token to process
     * @param type type of the token
     */
    private void visitOtherTokens(DetailAST ast, int type)
    {
        //A more thorough check of enum constant class bodies is
        //possible (checking for hidden fields against the enum
        //class body in addition to enum constant class bodies)
        //but not attempted as it seems out of the scope of this
        //check.
        final DetailAST typeMods = ast.findFirstToken(TokenTypes.MODIFIERS);
        final boolean isStaticInnerType =
                typeMods != null
                        && typeMods.branchContains(TokenTypes.LITERAL_STATIC);

        final FieldFrame frame =
            new FieldFrame(currentFrame, isStaticInnerType,
                    type == TokenTypes.CLASS_DEF || type == TokenTypes.ENUM_DEF
                    ? ast.findFirstToken(TokenTypes.IDENT).getText()
                    : null
            );

        //add fields to container
        final DetailAST objBlock = ast.findFirstToken(TokenTypes.OBJBLOCK);
        // enum constants may not have bodies
        if (objBlock != null) {
            DetailAST child = objBlock.getFirstChild();
            while (child != null) {
                if (child.getType() == TokenTypes.VARIABLE_DEF) {
                    final String name =
                        child.findFirstToken(TokenTypes.IDENT).getText();
                    final DetailAST mods =
                        child.findFirstToken(TokenTypes.MODIFIERS);
                    if (mods.branchContains(TokenTypes.LITERAL_STATIC)) {
                        frame.addStaticField(name);
                    }
                    else {
                        frame.addInstanceField(name);
                    }
                }
                child = child.getNextSibling();
            }
        }
        // push container
        currentFrame = frame;
    }

