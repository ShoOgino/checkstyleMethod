    /**
     * The doclet's starter method.
     * @param root {@code RootDoc} given to the doclet
     * @return true if the given {@code RootDoc} is processed.
     * @exception FileNotFoundException will be thrown if the doclet
     *            will be unable to write to the specified file.
     */
    public static boolean start(RootDoc root)
            throws FileNotFoundException {
        final String fileName = getDestFileName(root.options());
        final FileOutputStream fos = new FileOutputStream(fileName);
        final Writer osw = new OutputStreamWriter(fos, StandardCharsets.UTF_8);
        final PrintWriter writer = new PrintWriter(osw, false);

        try {
            final ClassDoc[] classes = root.classes();
            final FieldDoc[] fields = classes[0].fields();
            for (final FieldDoc field : fields) {
                if (field.isStatic() && field.isPublic() && field.isFinal()
                    && "int".equals(field.type().qualifiedTypeName())) {
                    // We have to filter "Text" tags because of jdk parsing bug
                    // till Oracle reference id: 9050448
                    if (field.firstSentenceTags().length != 1
                            && Arrays.stream(field.firstSentenceTags())
                            .filter(tag -> !"Text".equals(tag.name())).count() != 1) {
                        final List<Tag> tags = Arrays.asList(field.firstSentenceTags());
                        final String joinedTags = tags
                            .stream()
                            .map(Tag::toString)
                            .collect(Collectors.joining("\", \"", "[\"", "\"]"));
                        final String message = String.format(Locale.ROOT,
                                "Should be only one tag for %s. Tags %s.",
                                field.toString(), joinedTags);
                        throw new IllegalArgumentException(message);
                    }
                    writer.println(field.name() + "="
                            + field.firstSentenceTags()[0].text());
                }
            }
        }
        finally {
            writer.close();
        }

        return true;
    }

