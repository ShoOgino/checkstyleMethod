    /**
     * It is OK to have long test method name here as it describes the test purpose.
     * @noinspection InstanceMethodNamingConvention
     */
    // -@cs[ExecutableStatementCount] This test needs to verify many things.
    @Test
    public void testCacheAndCheckWhichAddsNewResourceLocationButKeepsSameCheckerInstance()
            throws Exception {

        // Use case (https://github.com/checkstyle/checkstyle/pull/3092#issuecomment-218162436):
        // Imagine that cache exists in a file. New version of Checkstyle appear.
        // New release contains update to a some check to have additional external resource.
        // User update his configuration and run validation as usually.
        // Cache should not be reused.

        final DynamicalResourceHolderCheck check = new DynamicalResourceHolderCheck();
        final String firstExternalResourceLocation = getPath("InputCheckerImportControlOne.xml");
        final String firstExternalResourceKey = PropertyCacheFile.EXTERNAL_RESOURCE_KEY_PREFIX
                + firstExternalResourceLocation;
        check.setFirstExternalResourceLocation(firstExternalResourceLocation);

        final DefaultConfiguration checkerConfig = createRootConfig(null);
        final File cacheFile = temporaryFolder.newFile();
        checkerConfig.addAttribute("cacheFile", cacheFile.getPath());

        final Checker checker = new Checker();
        checker.setModuleClassLoader(Thread.currentThread().getContextClassLoader());
        checker.addFileSetCheck(check);
        checker.addFilter(new DummyFilterSet());
        checker.configure(checkerConfig);
        checker.addListener(getBriefUtLogger());

        final String pathToEmptyFile = temporaryFolder.newFile("file.java").getPath();
        final String[] expected = CommonUtils.EMPTY_STRING_ARRAY;

        verify(checker, pathToEmptyFile, expected);
        final Properties cacheAfterFirstRun = new Properties();
        cacheAfterFirstRun.load(Files.newBufferedReader(cacheFile.toPath()));

        final int expectedNumberOfObjectsInCacheAfterFirstRun = 4;
        assertEquals("Number of items in cache differs from expected",
                expectedNumberOfObjectsInCacheAfterFirstRun, cacheAfterFirstRun.size());

        // Change a list of external resources which are used by the check
        final String secondExternalResourceLocation = "InputCheckerImportControlTwo.xml";
        final String secondExternalResourceKey = PropertyCacheFile.EXTERNAL_RESOURCE_KEY_PREFIX
                + secondExternalResourceLocation;
        check.setSecondExternalResourceLocation(secondExternalResourceLocation);

        checker.addFileSetCheck(check);
        checker.configure(checkerConfig);

        verify(checker, pathToEmptyFile, expected);
        final Properties cacheAfterSecondRun = new Properties();
        cacheAfterSecondRun.load(Files.newBufferedReader(cacheFile.toPath()));

        assertEquals("Cache file has changed its path",
            cacheAfterFirstRun.getProperty(pathToEmptyFile),
            cacheAfterSecondRun.getProperty(pathToEmptyFile)
        );
        assertEquals(
                "Cache has changed its hash",
            cacheAfterFirstRun.getProperty(PropertyCacheFile.CONFIG_HASH_KEY),
            cacheAfterSecondRun.getProperty(PropertyCacheFile.CONFIG_HASH_KEY)
        );
        assertEquals("Cache has changed its resource key",
            cacheAfterFirstRun.getProperty(firstExternalResourceKey),
            cacheAfterSecondRun.getProperty(firstExternalResourceKey)
        );
        assertNotNull("Cache has null as a resource key",
                cacheAfterFirstRun.getProperty(firstExternalResourceKey));
        final int expectedNumberOfObjectsInCacheAfterSecondRun = 4;
        assertEquals("Number of items in cache differs from expected",
                expectedNumberOfObjectsInCacheAfterSecondRun, cacheAfterSecondRun.size());
        assertNull("Cache has not null as a resource key",
                cacheAfterFirstRun.getProperty(secondExternalResourceKey));
        assertNotNull("Cache has null as a resource key",
                cacheAfterSecondRun.getProperty(secondExternalResourceKey));
    }

