    /**
     * Processes a specified file and prints out all errors found.
     * @return the number of errors found
     * @param aFileName the name of the file to process
     **/
    private int process(String aFileName)
    {
        // check if already checked and passed the file
        final File f = new File(aFileName);
        final long timestamp = f.lastModified();
        if (mCache.alreadyChecked(aFileName, timestamp)) {
            return 0;
        }

        // Create a stripped down version
        final String stripped;
        final String basedir = mConfig.getBasedir();
        if ((basedir == null) || !aFileName.startsWith(basedir)) {
            stripped = aFileName;
        }
        else {
            // making the assumption that there is text after basedir
            final int skipSep = basedir.endsWith(File.separator) ? 0 : 1;
            stripped = aFileName.substring(basedir.length() + skipSep);
        }

        LocalizedMessage[] errors;
        try {
            fireFileStarted(stripped);
            final String[] lines = getLines(aFileName);
            try {
                // try the 1.4 grammar first, this will succeed for
                // all code that compiles without any warnings in JDK 1.4,
                // that should cover most cases
                VerifierSingleton.getInstance().clearMessages();
                VerifierSingleton.getInstance().setLines(lines);
                final Reader sar = new StringArrayReader(lines);
                final GeneratedJava14Lexer jl = new GeneratedJava14Lexer(sar);
                jl.setFilename(aFileName);
                final GeneratedJava14Recognizer jr =
                    new SilentJava14Recognizer(jl);
                jr.setFilename(aFileName);
                jr.setASTNodeClass(MyCommonAST.class.getName());
                jr.compilationUnit();
            }
            catch (RecognitionException re) {
                // Parsing might have failed because the checked
                // file contains "assert" as an identifier. Retry with a
                // grammar that treats "assert" as an identifier
                // and not as a keyword

                // Arghh - the pain - duplicate code!
                VerifierSingleton.getInstance().clearMessages();
                VerifierSingleton.getInstance().setLines(lines);
                final Reader sar = new StringArrayReader(lines);
                final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);
                jl.setFilename(aFileName);
                final GeneratedJavaRecognizer jr =
                    new GeneratedJavaRecognizer(jl);
                jr.setFilename(aFileName);
                jr.setASTNodeClass(MyCommonAST.class.getName());
                jr.compilationUnit();
            }
            errors = VerifierSingleton.getInstance().getMessages();
        }
        catch (FileNotFoundException fnfe) {
            errors = new LocalizedMessage[] {
                new LocalizedMessage(0, "general.fileNotFound", null)};
        }
        catch (IOException ioe) {
            errors = new LocalizedMessage[] {
                new LocalizedMessage(0, "general.exception",
                                     new String[] {ioe.getMessage()})};
        }
        catch (RecognitionException re) {
            errors = new LocalizedMessage[] {
                new LocalizedMessage(0, "general.exception",
                                     new String[] {re.getMessage()})};
        }
        catch (TokenStreamException te) {
            errors = new LocalizedMessage[] {
                new LocalizedMessage(0, "general.exception",
                                     new String[] {te.getMessage()})};
        }

        if (errors.length == 0) {
            mCache.checkedOk(aFileName, timestamp);
        }
        else {
            fireErrors(stripped, errors);
        }

        fireFileFinished(stripped);
        return errors.length;
    }

