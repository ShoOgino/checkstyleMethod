    /** {@inheritDoc} */
    public void leaveToken(DetailAST aAST)
    {
        final int type = aAST.getType();
        final DetailAST parent = aAST.getParent();

        if ((type == TokenTypes.ASSIGN)
            && (parent.getType() == TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR))
        {
            // shouldn't process assign in annotation pairs
            return;
        }

        // An expression is surrounded by parentheses.
        if (type == TokenTypes.EXPR) {

            // If 'mParentToSkip' == 'aAST', then we've already logged a
            // warning about an immediate child node in visitToken, so we don't
            // need to log another one here.

            if ((mParentToSkip != aAST) && exprSurrounded(aAST)) {
                if (mAssignDepth >= 1) {
                    log(aAST, "unnecessary.paren.assign");
                }
                else if (aAST.getParent().getType()
                    == TokenTypes.LITERAL_RETURN)
                {
                    log(aAST, "unnecessary.paren.return");
                }
                else {
                    log(aAST, "unnecessary.paren.expr");
                }
            }

            mParentToSkip = null;
        }
        else if (inTokenList(type, ASSIGNMENTS)) {
            mAssignDepth--;
        }

        super.leaveToken(aAST);
    }

