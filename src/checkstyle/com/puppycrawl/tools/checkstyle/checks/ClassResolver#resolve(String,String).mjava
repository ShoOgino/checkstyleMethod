    /**
     * Attempts to resolve the Class for a specified name. The algorithm is
     * to check:
     * - fully qualified name
     * - explicit imports
     * - enclosing package
     * - star imports
     * @param aName name of the class to resolve
     * @param aCurrentClass name of current class (for inner classes).
     * @return the resolved class
     * @throws ClassNotFoundException if unable to resolve the class
     */
    public Class resolve(String aName, String aCurrentClass)
        throws ClassNotFoundException
    {
        // See if the class is full qualified
        if (isLoadable(aName)) {
            return safeLoad(aName);
        }
        //Perhaps it's fully-qualified inner class
        int dotIdx = aName.lastIndexOf(".");
        if (dotIdx != -1) {
            final String cn = aName.substring(0, dotIdx) + "$"
                + aName.substring(dotIdx + 1);
            if (isLoadable(cn)) {
                return safeLoad(cn);
            }
        }

        // try matching explicit imports
        Iterator it = mImports.iterator();
        while (it.hasNext()) {
            final String imp = (String) it.next();
            // Very important to add the "." in the check below. Otherwise you
            // when checking for "DataException", it will match on
            // "SecurityDataException". This has been the cause of a very
            // difficult bug to resolve!
            if (imp.endsWith("." + aName)) {
                if (isLoadable(imp)) {
                    return safeLoad(imp);
                }
                // perhaps this is a import for inner class
                // let's try load it.
                final int dot = imp.lastIndexOf(".");
                if (dot != -1) {
                    final String innerName = imp.substring(0, dot) + "$"
                        + imp.substring(dot + 1);
                    if (isLoadable(innerName)) {
                        return safeLoad(innerName);
                    }
                }
            }
        }

        // See if in the package
        if (!"".equals(mPkg)) {
            final String fqn = mPkg + "." + aName;
            if (isLoadable(fqn)) {
                return safeLoad(fqn);
            }
        }

        //inner class of this class???
        if (!"".equals(aCurrentClass)) {
            final String innerClass = (!"".equals(mPkg) ? (mPkg + ".") : "")
                + aCurrentClass + "$" + aName;
            if (isLoadable(innerClass)) {
                return safeLoad(innerClass);
            }
        }

        // try "java.lang."
        final String langClass = "java.lang." + aName;
        if (isLoadable(langClass)) {
            return safeLoad(langClass);
        }

        // try star imports
        it = mImports.iterator();
        while (it.hasNext()) {
            final String imp = (String) it.next();
            if (imp.endsWith(".*")) {
                final String fqn = imp.substring(0, imp.lastIndexOf('.') + 1)
                    + aName;
                if (isLoadable(fqn)) {
                    return safeLoad(fqn);
                }
            }
        }

        // Giving up, the type is unknown, so load the class to generate an
        // exception
        return safeLoad(aName);
    }

