    /**
     * Resolves Java expressions, returning the type to which the expression
     * evalutes.  If this is the reference creation phase, any references found during resolution are created and
     * resolved.
     *
     * @param expression the <code>SymTabAST</code> representing the expression
     * @param location the <code>Scope</code> in which the expression occours.
     * @param context the <code>Scope</code> in which the search for the
     *                definition will start
     * @param referencePhase whether or not this is the reference phase of
     *                       table construction
     *
     * @return the <code>ClassDef</code> representing the type to which the
     *         expression evalutes.
     */
    public IClass resolveExpression(
        SymTabAST expression,
        Scope location,
        IClass context,
        boolean referencePhase) {
        IClass result = null;

        try {

            switch (expression.getType()) {

                case TokenTypes.TYPECAST :
                    result =
                        resolveTypecast(
                            expression,
                            location,
                            context,
                            referencePhase);
                    break;
                case TokenTypes.EXPR :
                case TokenTypes.LITERAL_RETURN :
                    if (expression.getFirstChild() != null) {
                        result =
                            resolveExpression(
                                (SymTabAST) expression.getFirstChild(),
                                location,
                                context,
                                referencePhase);
                    }
                    else {
                        // YOU WRITE BAD CODE!
                    }
                    break;

                case TokenTypes.ELIST :

                    SymTabAST child = (SymTabAST) (expression.getFirstChild());
                    while (child != null) {
                        if (child.getType() != TokenTypes.COMMA) {
                            resolveExpression(
                                child,
                                location,
                                context,
                                referencePhase);
                        }
                        child = (SymTabAST) (child.getNextSibling());
                    }
                    break;

                case TokenTypes.IDENT :
                    result =
                        resolveIdent(
                            expression,
                            location,
                            context,
                            referencePhase);
                    break;

                case TokenTypes.TYPE :
                    result =
                        resolveType(
                            expression,
                            location,
                            context,
                            referencePhase);
                    break;

                case TokenTypes.METHOD_CALL :
                //case TokenTypes.SUPER_CTOR_CALL :
                    result =
                        resolveMethod(
                            expression,
                            location,
                            context,
                            referencePhase);
                    break;

                case TokenTypes.LITERAL_THIS :
                    result = resolveLiteralThis(expression, location, context);
                    break;

                case TokenTypes.LITERAL_SUPER :
                    result = resolveLiteralSuper(expression, location, context);
                    break;

                case TokenTypes.DOT :
                    result =
                        resolveDottedName(
                            expression,
                            location,
                            context,
                            referencePhase);
                    break;

                case TokenTypes.LITERAL_NEW :
                case TokenTypes.CTOR_CALL :
                case TokenTypes.SUPER_CTOR_CALL :
                    result =
                        resolveNew(
                            expression,
                            location,
                            context,
                            referencePhase);
                    break;

                case TokenTypes.LITERAL_BOOLEAN :
                case TokenTypes.LITERAL_DOUBLE :
                case TokenTypes.LITERAL_FLOAT :
                case TokenTypes.LITERAL_LONG :
                case TokenTypes.LITERAL_INT :
                case TokenTypes.LITERAL_SHORT :
                case TokenTypes.LITERAL_BYTE :
                case TokenTypes.LITERAL_CHAR :
                    result =
                        resolvePrimitiveType(
                            expression,
                            location,
                            context,
                            referencePhase);
                    break;

                case TokenTypes.NUM_INT :
                case TokenTypes.NUM_LONG :
                    result = resolveNumInt(expression, location, context);
                    break;

                case TokenTypes.NUM_FLOAT :
                case TokenTypes.NUM_DOUBLE :
                    result = resolveNumFloat(expression, location, context);
                    break;

                case TokenTypes.STRING_LITERAL :
                    result =
                        resolveStringLiteral(expression, location, context);
                    break;

                case TokenTypes.CHAR_LITERAL :
                    result = resolveCharLiteral(expression, location, context);
                    break;

                case TokenTypes.ASSIGN :
                case TokenTypes.PLUS_ASSIGN :
                case TokenTypes.MINUS_ASSIGN :
                case TokenTypes.STAR_ASSIGN :
                case TokenTypes.DIV_ASSIGN :
                case TokenTypes.MOD_ASSIGN :
                case TokenTypes.SR_ASSIGN :
                case TokenTypes.BSR_ASSIGN :
                case TokenTypes.SL_ASSIGN :
                case TokenTypes.BAND_ASSIGN :
                case TokenTypes.BXOR_ASSIGN :
                case TokenTypes.BOR_ASSIGN :
                    resolveAssignment(
                        expression,
                        location,
                        context,
                        referencePhase);
                    break;

                case TokenTypes.LOR :
                case TokenTypes.LAND :
                case TokenTypes.NOT_EQUAL :
                case TokenTypes.EQUAL :
                case TokenTypes.LT :
                case TokenTypes.GT :
                case TokenTypes.LE :
                case TokenTypes.GE :
                    result =
                        resolveBooleanExpression(
                            expression,
                            location,
                            context,
                            referencePhase);
                    break;

                case TokenTypes.LITERAL_INSTANCEOF :
                    result =
                        resolveInstanceOf(
                            expression,
                            location,
                            context,
                            referencePhase);
                    break;

                case TokenTypes.LITERAL_TRUE :
                case TokenTypes.LITERAL_FALSE :
                    result =
                        resolveBooleanLiteral(expression, location, context);
                    break;

                case TokenTypes.LNOT :
                    result =
                        resolveBooleanUnary(
                            expression,
                            location,
                            context,
                            referencePhase);
                    break;

                case TokenTypes.INC :
                case TokenTypes.POST_INC :
                case TokenTypes.DEC :
                case TokenTypes.POST_DEC :
                case TokenTypes.UNARY_PLUS :
                case TokenTypes.UNARY_MINUS :
                    result =
                        resolveUnaryExpression(
                            expression,
                            location,
                            context,
                            referencePhase);
                    break;

                case TokenTypes.PLUS :
                case TokenTypes.MINUS :
                case TokenTypes.DIV :
                case TokenTypes.STAR :
                case TokenTypes.BAND :
                case TokenTypes.BOR :
                case TokenTypes.BXOR :
                case TokenTypes.MOD :
                    result =
                        resolveArithmeticExpression(
                            expression,
                            location,
                            context,
                            referencePhase);
                    break;

                case TokenTypes.LITERAL_BREAK :
                case TokenTypes.LITERAL_CONTINUE :
                    resolveGoto(expression, location, context, referencePhase);
                    break;

                case TokenTypes.LPAREN :
                    result = resolveExpression(
                        //TODO: child || sibling?
     (SymTabAST) (expression.getNextSibling()),
                        //(SymTabAST) (expression.getFirstChild()),
    location, context, referencePhase);
                    break;

                case TokenTypes.INDEX_OP :
                    result =
                        resolveArrayAccess(
                            expression,
                            location,
                            context,
                            referencePhase);
                    break;

                case TokenTypes.LITERAL_NULL :
                    result = new NullClass();
                    break;

                case TokenTypes.QUESTION :
                    result =
                        resolveQuestion(
                            expression,
                            location,
                            context,
                            referencePhase);
                    break;

                case TokenTypes.LITERAL_CLASS :
                    result = resolveLiteralClass();
                    break;

                case TokenTypes.ARRAY_INIT :
                    resolveArrayInitializer(
                        expression,
                        location,
                        context,
                        referencePhase);
                    break;

                case TokenTypes.LITERAL_THROW :
                    resolveThrowExpression(
                        expression,
                        location,
                        context,
                        referencePhase);
                    break;

                case TokenTypes.SL :
                case TokenTypes.SR :
                case TokenTypes.BSR :
                    result =
                        resolveShiftOperator(
                            expression,
                            location,
                            context,
                            referencePhase);
                    break;

                case TokenTypes.BNOT :
                    resolveBitwiseNot(
                        expression,
                        location,
                        context,
                        referencePhase);
                    break;

                case TokenTypes.LITERAL_ASSERT :
//                                        resolveAssert(
//                                            expression,
//                                            location,
//                                            context,
//                                            referencePhase);
                    break;

                case TokenTypes.RPAREN :
                case TokenTypes.EMPTY_STAT :
                    //    case TokenTypes.ML_COMMENT:
                    //    case TokenTypes.SL_COMMENT:
                case TokenTypes.VARIABLE_DEF :
                case TokenTypes.METHOD_DEF :
                case TokenTypes.CLASS_DEF :
                case TokenTypes.LITERAL_FOR :
                case TokenTypes.LITERAL_WHILE :
                case TokenTypes.LITERAL_IF :
                case TokenTypes.LITERAL_VOID :
                    //    case TokenTypes.LITERAL_INTERFACE:
                case TokenTypes.LITERAL_DO :
                case TokenTypes.LITERAL_SWITCH :
                case TokenTypes.LITERAL_STATIC :
                case TokenTypes.LITERAL_TRANSIENT :
                case TokenTypes.LITERAL_NATIVE :
                    //    case TokenTypes.LITERAL_threadsafe:
                case TokenTypes.LITERAL_SYNCHRONIZED :
                case TokenTypes.LITERAL_VOLATILE :
                case TokenTypes.LITERAL_TRY :
                case TokenTypes.LITERAL_CATCH :
                case TokenTypes.LITERAL_FINALLY :
                case TokenTypes.LABELED_STAT :
                case TokenTypes.LCURLY :
                case TokenTypes.RCURLY :
                case TokenTypes.SLIST :
                case TokenTypes.SEMI :
                case TokenTypes.COMMA :
                case TokenTypes.ARRAY_DECLARATOR :
                    break;

                default :
                //TODO: throw exception
                    if (mInitialized) {
                        final Log log =
                            mLogFactory.getInstance(this.getClass());
                        log.error(
                            "Unhandled expression type: "
                                + expression.getType());
                    }
                    break;
            }
        }
        catch (Exception e) {
            
            result = new UnknownClass(expression.getText(), expression);
//          TODO: This really should be logged
//            if (mInitialized) {
//                final Log log = mLogFactory.getInstance(this.getClass());
//                log.error("Error resolving near " + expression);
//            }
        }

        return result;
    }

