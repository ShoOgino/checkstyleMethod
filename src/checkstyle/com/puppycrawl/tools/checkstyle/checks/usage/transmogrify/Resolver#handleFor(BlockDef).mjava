    /**
     * processes a for loop and resolves references in it
     *
     * @param block the <code>BlockDef</code> to process
     */
    private void handleFor(BlockDef block) {
        SymTabAST node = block.getTreeNode();

        SymTabAST init = node.findFirstToken(TokenTypes.FOR_INIT);
        // only need to handle the elist case.  if the init node is a variable
        // definition, the variable def will be handled later on in the resolution
        if (init.getFirstChild() != null) {
            if (init.getFirstChild().getType() == TokenTypes.ELIST) {
                resolveExpression(
                    (SymTabAST) (init.getFirstChild()),
                    block,
                    null,
                    true);
            }
        }

        SymTabAST cond = node.findFirstToken(TokenTypes.FOR_CONDITION);
        if (cond.getFirstChild() != null) {
            resolveExpression(
                (SymTabAST) (cond.getFirstChild()),
                block,
                null,
                true);
        }

        SymTabAST iterator = node.findFirstToken(TokenTypes.FOR_ITERATOR);
        if (iterator.getFirstChild() != null) {
            resolveExpression(
                (SymTabAST) (iterator.getFirstChild()),
                block,
                null,
                true);
        }

        //could be an SLIST, EXPR or an EMPTY_STAT
        SymTabAST body = (SymTabAST) (iterator.getNextSibling());
        // handle Checkstyle grammar
        if (body.getType() == TokenTypes.RPAREN) {
            body = (SymTabAST) body.getNextSibling();
        }
        if (body.getType() == TokenTypes.SLIST) {
            handleSList(body, block);
        }
        else {
            resolveExpression(body, block, null, true);
        }

    }

