  /**
   * processes a single SymTabAST node based on its type and passes of its
   * children for further processing where appropriate.
   *
   * @param tree the <code>SymTabAST</code> node to process
   * @param makeAnonymousScopes sets to <code>false</code> after walking Class,
   *                            Methods and Try otherwise sets to <code>true</code>
   * @return <code>void</code>
   * @see #walkSiblings(SymTabAST, boolean)
   * @see #processAnonymousInnerClass(SymTabAST, SymTabAST)
   * @see #processBlock(SymTabAST, boolean)
   * @see #processClass(SymTabAST)
   * @see #processConstructorDef(SymTabAST)
   * @see #processElse(SymTabAST)
   * @see #processFile(SymTabAST)
   * @see #processFinally(SymTabAST)
   * @see #processFor(SymTabAST)
   * @see #processImplicitPackage(SymTabAST)
   * @see #processImport(SymTabAST)
   * @see #processLabel(SymTabAST)
   * @see #processMethodDef(SymTabAST)
   * @see #processPackage(SymTabAST)
   * @see #processTry(SymTabAST)
   * @see net.sourceforge.transmogrify.symtab.antlr.SymTabAST
   * @see net.sourceforge.transmogrify.symtab.antlr.JavaTokenTypes
   */
  public void walkTree(SymTabAST tree, boolean makeAnonymousScopes) {

    if (tree != null) {

      tree.setScope( symbolTable.getCurrentScope() );

      switch(tree.getType()) {
      case 0:
        processFile(tree);
        if ( tree.getFirstChild().getType() != TokenTypes.PACKAGE_DEF ) {
          processImplicitPackage( tree.getFile() );
        }

        walkSiblings((SymTabAST)tree.getFirstChild(), false);

        // pop package scope
        symbolTable.popScope();
        clearImports();
        break;

      case TokenTypes.LITERAL_NEW:
        SymTabAST symtabTree = tree;
        //walk parameters, in case of anonymous inner class
        walkTree(symtabTree.findFirstToken(TokenTypes.ELIST),
          makeAnonymousScopes);
        SymTabAST objblock
          = symtabTree.findFirstToken(TokenTypes.OBJBLOCK);
        if (objblock != null) {
          SymTabAST classExtended
            = symtabTree.findFirstToken(TokenTypes.IDENT);

          processAnonymousInnerClass(objblock, classExtended);
        }
        break;

      case TokenTypes.SLIST:
        if (makeAnonymousScopes) {
          processBlock(tree, true);
        }
        else {
          walkSiblings((SymTabAST)tree.getFirstChild(), true);
        }
        break;

      case TokenTypes.CTOR_DEF:
        processConstructorDef(tree);
        break;

      case TokenTypes.METHOD_DEF:
        processMethodDef(tree);
        break;

      case TokenTypes.LITERAL_FINALLY:
        processFinally(tree);
        break;

      case TokenTypes.LITERAL_TRY:
        processTry(tree);
        break;

      case TokenTypes.VARIABLE_DEF:
        processVariableDef(tree);
        break;

      case TokenTypes.PACKAGE_DEF:
        processPackage(tree);
        break;

      case TokenTypes.LABELED_STAT:
        processLabel(tree);
        break;

      case TokenTypes.IMPORT:
        processImport(tree);
        break;

      case TokenTypes.CLASS_DEF:
      case TokenTypes.INTERFACE_DEF:
        processClass(tree);
        break;

      case TokenTypes.LITERAL_FOR:
        processFor(tree);
        break;

      case TokenTypes.LITERAL_IF:
        processIf(tree);
        break;
      
      case TokenTypes.LITERAL_ASSERT:
        processAssert(tree);
        break;

      case TokenTypes.LITERAL_CATCH:
      case TokenTypes.LITERAL_WHILE:
      case TokenTypes.LITERAL_SWITCH:
      case TokenTypes.LITERAL_DO:
      case TokenTypes.LITERAL_SYNCHRONIZED:
      case TokenTypes.STATIC_INIT:
      case TokenTypes.INSTANCE_INIT:
        processBlock(tree, false);
        break;

      default:
        walkSiblings((SymTabAST)tree.getFirstChild(), false);
      }
    }
  }

