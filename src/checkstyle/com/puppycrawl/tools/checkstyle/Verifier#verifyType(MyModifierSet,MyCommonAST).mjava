    /**
     * Verify that a type conforms to the style.
     * @param aMods the set of modifiers for the type
     * @param aType the type details
     **/
    void verifyType(MyModifierSet aMods, MyCommonAST aType)
    {
        if (!mConfig.getTypeRegexp().match(aType.getText())) {
            mMessages.add(aType.getLineNo(), aType.getColumnNo(),
                          "name.invalidPattern",
                          aType.getText(), mConfig.getTypePat());
        }

        // Always check that the order of modifiers follows the JLS suggestion
        checkModOrder(aMods);

        //
        // Only Javadoc testing below
        //
        final Scope typeScope =
            inInterfaceBlock() ? Scope.PUBLIC : aMods.getVisibilityScope();

        if (!inCheckScope(typeScope)) {
            return; // no need to really check anything
        }

        final int lineNo = (aMods.size() > 0)
            ? aMods.getFirstLineNo()
            : aType.getLineNo();

        final String[] jd = getJavadocBefore(lineNo - 1);
        if (jd == null) {
            mMessages.add(lineNo, "javadoc.missing");
        }
        else if (mInScope.size() == 0) {
            // don't check author/version for inner classes
            if (!mConfig.isAllowNoAuthor()
                && (MATCH_JAVADOC_AUTHOR.grep(jd).length == 0))
            {
                mMessages.add(lineNo, "type.missingTag", "@author");
            }
            if (mConfig.isRequireVersion()
                && (MATCH_JAVADOC_VERSION.grep(jd).length == 0))
            {
                mMessages.add(lineNo, "type.missingTag", "@version");
            }
        }
    }

