    /**
     * Verify that a valid Javadoc comment exists for the method.
     * @param aSig the method signature
     **/
    void verifyMethod(MethodSignature aSig)
    {
        // no need to check constructor names
        if (!aSig.isConstructor()
            && !mConfig.getMethodRegexp().match(aSig.getName().getText()))
        {
            mMessages.add(aSig.getName().getLineNo(),
                          aSig.getName().getColumnNo(),
                          "name.invalidPattern",
                          aSig.getName().getText(),
                          mConfig.getMethodPat());
        }

        // Always check that the order of modifiers follows the JLS suggestion
        checkModOrder(aSig.getModSet());

        // Check for to many parameters
        if (aSig.getParams().size() > mConfig.getMaxParameters()) {
            mMessages.add(aSig.getFirstLineNo(),
                          aSig.getFirstColNo(),
                          "maxParam", new Integer(mConfig.getMaxParameters()));
        }
        // JLS, chapter 9.4 - public in interface is strongly discouraged
        if (!mConfig.isIgnorePublicInInterface() && inInterfaceBlock()
            && aSig.getModSet().containsPublic())
        {
            mMessages.add(aSig.getModSet().getFirstLineNo(),
                          aSig.getModSet().getFirstColNo(),
                          "redundantModifier", "public");
        }

        // Check for redunant abstract
        if (inInterfaceBlock() && aSig.getModSet().containsAbstract()) {
            mMessages.add(aSig.getModSet().getFirstLineNo(),
                          aSig.getModSet().getFirstColNo(),
                          "redundantModifier", "abstract");
        }
        // now check the javadoc
        final Scope methodScope = inInterfaceBlock()
            ? Scope.PUBLIC
            : aSig.getModSet().getVisibilityScope();

        if (!inCheckScope(methodScope)) {
            return; // no need to really check anything
        }

        final String[] jd = getJavadocBefore(aSig.getFirstLineNo() - 1);
        if (jd == null) {
            mMessages.add(aSig.getFirstLineNo(),
                          aSig.getFirstColNo(),
                          "javadoc.missing");
        }
        else {
            final List tags = getMethodTags(jd, aSig.getFirstLineNo() - 1);
            // Check for only one @see tag
            if ((tags.size() != 1)
                || !((JavadocTag) tags.get(0)).isSeeTag())
            {
                checkParamTags(tags, aSig.getParams());
                checkThrowsTags(tags, aSig.getThrows());
                if (aSig.isFunction()) {
                    checkReturnTag(tags, aSig.getFirstLineNo());
                }

                // Dump out all unused tags
                final Iterator it = tags.iterator();
                while (it.hasNext()) {
                    final JavadocTag jt = (JavadocTag) it.next();
                    if (!jt.isSeeTag()) {
                        mMessages.add(jt.getLineNo(),
                                      "javadoc.unusedTagGeneral");
                    }
                }
            }
        }
    }

